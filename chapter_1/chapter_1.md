## An Intro To An Intro

Book introductions are hard. As an author, you want to talk about so much, but
you're not quire sure how to communicate your vision clearly enough. While it
might seem that Chapter 1 should be heavily on the basic examples and easy
concepts, I was surprised about how much "process oriented" stuff was discussed.

The first few pages talk about why design is important, but the importance of
design often leads into the pros (and cons) of change.

> Changing requirements are the programming equivalent of friction and gravity
> they introduce forces that apply sudden and unexpected pressures that work
> against the best-laid plans.

Ending with:

> It is the need for change that makes design matter.

There's a pretty good TL;DR on design. We often design and write programming
as if it exists within a vaccum. However, weird stuff happens. Requirements
change. Companies rise and fall. We're starting to chase after this idea that
good code is adaptable. It survives evolution in many ways.

## Dependencies?

> Object-Oriented design is about managing Dependencies.

Interesting, but true. Dependency bloat in many ways could be considered bad
design.

## Starting Early

> In small applications, poor design is survivable...The problem with poorly
> designed small applications is that they grow up to be poorly designed big
> applications.

You might think: "Well, duh." However, I've seen this happen so much in the
professional world. Why is that? I think it comes down the developers (and
management) never taking the time to fix mistakes early on.

In essence: bad mistakes and design compound over time.

## We're Artists?

I've been after the idea that programmers are artists for awhile now. The idea
translates easy for me because of my musical and creative background. In what
way are programmers artists and designers?

Well, there are many actually. The specific art Sandi is getting at is this:

> Design is thus an art, the art of arranging code

Software Design is the art of arranging code. I like that a lot. We often view
not knowing how to implement something as the main problem in creating a
product. Yet, the implementation is only half the problem.

The thought translates really well to other mediums as well. I can know how to
play certain guitar chords. However, its the dynamics and arrangement of those
chords that really matters. Sometimes the best songs in the world are simple
chord progressions that have the right arrangement. I'm starting to learn the
same can come out of programming.

## Put It Off

> The purpose of design is to allow you to do design later and its primary goal
> is to reduce the cost of change.

Again, I think we think of design as a one time thing. Just design up front
(more on that later) and program away! This sometimes works, but you get lost
pretty quickly if its a big project. We want to design to design later.

That's weird to say.

## Too Much Design?

> Pattern misapplication results in complicated and confusing code but this
> result is not the fault of the pattern itself. A tool cannot be faulted for
> its use, the user must master the tool. 
